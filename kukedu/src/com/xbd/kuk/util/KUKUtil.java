package com.xbd.kuk.util;import java.io.IOException;import java.nio.CharBuffer;import java.nio.charset.Charset;import java.text.DecimalFormat;import java.text.SimpleDateFormat;import java.util.ArrayList;import java.util.Date;import java.util.HashMap;import java.util.List;import java.util.Map;import java.util.regex.Matcher;import java.util.regex.Pattern;import com.xbd.kuk.R;import android.app.Activity;import android.content.Context;import android.content.res.TypedArray;import android.graphics.Bitmap;import android.graphics.BitmapFactory;import android.graphics.Color;import android.graphics.Matrix;import android.graphics.Typeface;import android.graphics.drawable.Drawable;import android.media.ExifInterface;import android.text.Html;import android.text.Html.ImageGetter;import android.text.Spannable;import android.text.SpannableString;import android.text.SpannableStringBuilder;import android.text.Spanned;import android.text.SpannedString;import android.text.style.ForegroundColorSpan;import android.text.style.ImageSpan;import android.text.style.StyleSpan;import android.text.style.TypefaceSpan;import android.util.Log;import android.view.WindowManager;import android.widget.TextView;/** * 资源工具类 *  * @ClassName: OBUtil * @Description: TODO * @author zhangchunzhe * @date 2013-3-8 下午5:32:30 *  */public class KUKUtil {	private static final String TAG = "OBUtil";	private static final int STRING_FORMAT_MIN_LENGTH = 8;	private static KUKUtil instance;	public static KUKUtil getInstance() {		if (instance == null)			instance = new KUKUtil();		return instance;	}	/**	 * 获取资源字符串	 * 	 * @param context	 * @param id	 * @return	 */	public static String getString(Context context, int id) {		return context.getResources().getString(id);	}	/**	 * 获取带参数的资源字符串	 * 	 * @param context	 * @param id	 * @param objects	 * @return	 */	public static String getString(Context context, int id, Object... objects) {		return context.getResources().getString(id, objects);	}	/**	 * 获取的资源图片	 * 	 * @param context	 * @param id	 * @param objects	 * @return	 */	public static Drawable getDrawable(Context context, int id) {		return context.getResources().getDrawable(id);	}	/**	 * 获取的资源图片	 * 	 * @param context	 * @param id	 * @param objects	 * @return	 */	public static int getColor(Context context, int id) {		return context.getResources().getColor(id);	}	/**	 * 显示HTML格式文本	 * 	 * @param text	 * @return	 */	public static String getHTMLString(String text) {		return Html.fromHtml(text).toString();	}	/**	 * 显示格式化时间字符串(带时分秒)	 * 	 * @param date	 * @return	 */	public static String getDateFormatString(Date date) {		SimpleDateFormat dateFormat = new SimpleDateFormat(				"yyyy-MM-dd HH:mm:ss");		return dateFormat.format(date);	}	/**	 * 显示格式化日期字符串	 * 	 * @param date	 * @return	 */	public static String getDateFormatHourString(Date date) {		SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd");		return dateFormat.format(date);	}	public static String getSubString(String str, int number) {		return str.substring(0, 20);	}	/**	 * 获取当前屏幕的全屏大小	 * 	 * @param activity	 * @return	 */	public static int[] getScreenRect(Activity activity) {		WindowManager manager = activity.getWindowManager();		int sreenW = manager.getDefaultDisplay().getWidth();		int sreenH = manager.getDefaultDisplay().getHeight();		return new int[] { sreenW, sreenH };	}	/**	 * 根据地址的URL获取类型	 * 	 * @param url	 * @return	 */	public static int getFileTypeFromUrl(String url) {		String strType = url.substring(url.lastIndexOf(".") + 1);		if (strType.equalsIgnoreCase("png") || strType.equalsIgnoreCase("jpg")				|| strType.equalsIgnoreCase("jPEG")) {			return Constants.TYPE_JPG;		} else if (strType.equalsIgnoreCase("pdf")) {			return Constants.TYPE_PDF;		} else if (strType.equalsIgnoreCase("gif")) {			return Constants.TYPE_GIF;		} else {			return Constants.TYPE_OTHER;		}	}	/**	 * 获取文件类型	 * 	 * @param type	 * @return	 */	public static int getFileTypeFromStr(String type) {		if (type.equalsIgnoreCase("png") || type.equalsIgnoreCase("jpg")				|| type.equalsIgnoreCase("jPEG")) {			return Constants.TYPE_JPG;		} else if (type.equalsIgnoreCase("pdf")) {			return Constants.TYPE_PDF;		} else if (type.equalsIgnoreCase("gif")) {			return Constants.TYPE_GIF;		} else {			return Constants.TYPE_OTHER;		}	}	/**	 * 获取文件类型	 * 	 * @param type	 * @return	 */	public static String getFileType(String fileUrl) {		return fileUrl.substring(fileUrl.lastIndexOf(".") + 1);	}	/**	 * 获取文件类型	 * 	 * @param type	 * @return	 */	public static String getFileName(String fileUrl) {		String fileAllName = fileUrl.substring(fileUrl.lastIndexOf("/") + 1);		return fileAllName.substring(0, fileAllName.lastIndexOf("."));	}	/**	 * 显示输出保留一位有效数字	 * 	 * @param d	 * @return	 */	public static String getOneDecimal(double d) {		DecimalFormat df = new DecimalFormat("0.0");		return df.format(d);	}	/**	 * 格式化完形填空题文本	 * 	 * @param d	 * @return	 */	public static String getFormatQuestion(Context context, String question) {		String splitStr = "<input";		String endStr = "/>";		String[] questions = question.split(splitStr);		StringBuffer buffer = new StringBuffer();		int index = 0;		for (int i = 0; i < questions.length; i++) {			String str = questions[i];			if (str.contains(endStr)) {				index++;				String replace = str.substring(str.indexOf(endStr)						+ endStr.length());				buffer.append(getString(context,						R.string.homework_string_Line, index) + replace);			} else {				buffer.append(questions[i]);			}		}		return buffer.toString();	}	/**	 * 格式化公告内容（富文本中去掉公告链接显示处理）	 * 	 * @param d	 * @return	 */	public static String getFormatNoticeContent(String contents) {		String splitStr = "<A";		String endStr = "/A>";		String[] questions = contents.split(splitStr);		StringBuffer buffer = new StringBuffer();		for (int i = 0; i < questions.length; i++) {			String str = questions[i];			if (str.contains(endStr)) {				String replace = str.substring(0,						str.indexOf(endStr) + endStr.length());				String content = str.replace(replace, "");				buffer.append(content);			} else {				buffer.append(questions[i]);			}		}		String contents2 = buffer.toString();		String splitStr2 = "<IMG";		String endStr2 = ">";		questions = contents2.split(splitStr2);		StringBuffer buffer2 = new StringBuffer();		for (int i = 0; i < questions.length; i++) {			String str = questions[i];			if (str.contains(endStr2)) {				String replace = str.substring(0,				str.indexOf(endStr2) + endStr2.length());				String content = str.replace(replace, "");				buffer2.append(content);			} else {				buffer2.append(questions[i]);			}		}		return buffer2.toString();	}	/**	 * 	 * @param context	 * @param content	 * @return	 */	public static String getFormatNotice(String content) {		String replaceStr = "rn";		String str = content.replace(replaceStr, "\n");		return str;	}	/**	 * 	 * @param content	 * @return	 */	public static String getFormatString(String content) {		String replaceStr = "n";		String str = content.replace(replaceStr, "\n");		return str;	}	/**	 * 	 * @param context	 * @param content	 * @return	 */	public static String getFormatContent(String content, String value) {		String replaceStr = "rn";		String str = content.replace(replaceStr, value);		return str;	}	/**	 * 	 * @param title	 * @return	 */	public static String getFormatTitleString(String fileName) {		int index = fileName.lastIndexOf(".");		String name = null;		if (index != -1) {			name = fileName.substring(0, index);		} else {			name = fileName;		}		return name;	}	/**	 * 文本编辑框里添加图片	 * 	 * @param context	 * @param text	 * @return	 */	public static SpannableString getSearchTextDrawableString(Context context,			String text) {		Drawable drawable = getDrawable(context,				R.drawable.img_friend_search_icon);		drawable.setBounds(0, 0, drawable.getIntrinsicWidth(),				drawable.getIntrinsicHeight());		// 需要处理的文本，[smile]是需要被替代的文本		SpannableString spannable = new SpannableString("[search]  " + text);		// 要让图片替代指定的文字就要用ImageSpan		ImageSpan span = new ImageSpan(drawable, ImageSpan.ALIGN_BOTTOM);		// 开始替换，注意第2和第3个参数表示从哪里开始替换到哪里替换结束（start和end）		// 最后一个参数类似数学中的集合,[5,12)表示从5到12，包括5但不包括12		spannable.setSpan(span, 0, "[smile]".length() + 1,				Spannable.SPAN_INCLUSIVE_EXCLUSIVE);		return spannable;	}	/**	 * 	 * @param imgPath	 * @return	 */	public static int geImageRorateAngle(String imgPath) {		int angle = 0;		ExifInterface exif = null;		try {			exif = new ExifInterface(imgPath);		} catch (IOException e) {			e.printStackTrace();			exif = null;		}		if (exif != null) {			int ori = exif.getAttributeInt(ExifInterface.TAG_ORIENTATION,					ExifInterface.ORIENTATION_UNDEFINED);			switch (ori) {			case ExifInterface.ORIENTATION_ROTATE_90:				angle = 90;				break;			case ExifInterface.ORIENTATION_ROTATE_180:				angle = 180;				break;			case ExifInterface.ORIENTATION_ROTATE_270:				angle = 270;				break;			default:				angle = 0;				break;			}		}		return angle;	}	/**	 * 	 * @param bitmap	 * @param angle	 * @return	 */	public static Bitmap getBitmapFormRorateAngle(Bitmap bitmap, int angle) {		if (angle != 0) {			// 旋转图片			Matrix m = new Matrix();			m.postRotate(angle);			bitmap = Bitmap.createBitmap(bitmap, 0, 0, bitmap.getWidth(),					bitmap.getHeight(), m, true);		}		return bitmap;	}	/**	 * 压缩图片	 * 	 * @param path	 * @return	 */	public static Bitmap getHandleBitmap(String path) {		BitmapFactory.Options options = new BitmapFactory.Options();		options.inSampleSize = 6;		options.inDither = false;		options.inPurgeable = true;		options.inInputShareable = true;		options.inTempStorage = new byte[32 * 1024];		options.inPreferredConfig = Bitmap.Config.RGB_565;		return BitmapFactory.decodeFile(path, options);	}	public static Bitmap decodeSampledBitmapFromResource(String path,			int reqWidth, int reqHeight) {		// First decode with inJustDecodeBounds=true to check dimensions		final BitmapFactory.Options options = new BitmapFactory.Options();		// inJustDecodeBounds 为true的时候不消耗内存		options.inJustDecodeBounds = true;		BitmapFactory.decodeFile(path, options);		// Calculate inSampleSize		options.inSampleSize = calculateInSampleSize(options, reqWidth,				reqHeight);		options.inDither = false;		options.inPurgeable = true;		options.inInputShareable = true;		// options.inTempStorage = new byte[1024 * 1024 * 4];		options.inPreferredConfig = Bitmap.Config.RGB_565;		// Decode bitmap with inSampleSize set		options.inJustDecodeBounds = false;		return BitmapFactory.decodeFile(path, options);	}	// 计算图片的缩放比例	public static int calculateInSampleSize(BitmapFactory.Options options,			int reqWidth, int reqHeight) {		// Raw height and width of image		// 原始图片的比例		final int height = options.outHeight;		final int width = options.outWidth;		int inSampleSize = 1;		// if (height > reqHeight || width > reqWidth) {		//		// final int halfHeight = height / 2;		// final int halfWidth = width / 2;		//		// // Calculate the largest inSampleSize value that is a power of 2 and		// // keeps both		// // height and width larger than the requested height and width.		// while ((halfHeight / inSampleSize) > reqHeight		// && (halfWidth / inSampleSize) > reqWidth) {		// inSampleSize *= 2;		// }		// }		if (width > height && height > reqHeight) {			inSampleSize = height / reqHeight;		} else if (height > width && width > reqWidth) {			inSampleSize = width / reqWidth;		}		return inSampleSize;	}	/**	 * 获取好友的背景	 * 	 * @param index	 * @return	 */	public static Drawable getFriendBg(Context context, int index) {		TypedArray typedArray = context.getResources().obtainTypedArray(				R.array.friend_bg_array);		return typedArray.getDrawable(index);	}	/**	 * 	 * @param score	 */	public static int getUserLevel(int score) {		if (score >= 0 && score <= 50) {			return 1;		} else if (score >= 51 && score <= 120) {			return 2;		} else if (score >= 121 && score <= 310) {			return 3;		} else if (score >= 311 && score <= 430) {			return 4;		} else if (score >= 431 && score <= 580) {			return 5;		} else if (score >= 581 && score <= 770) {			return 6;		} else if (score >= 771 && score <= 1010) {			return 7;		} else {			return 8;		}	}	/**	 * 用来获取发言内容中转发人的姓名	 * 	 * @param textView	 * @param originalContent	 */	public String setNewTextContent(String originalContent) {		String newContent = "";		String normalPriex = "<b><tt><font color =\"black\">";		String normalSuffix = "</font></tt></b>";		String bluePriex = "<b><tt><font color =\"#7F3E6DDF\">";		if (originalContent.equals("")) {			newContent = "转发";		} else {			String matchPri = "@[\u4E00-\u9FFFa-zA-Z0-9]+";			Pattern pattern = Pattern.compile(matchPri);			Matcher matcher = null;			List<Map<String, Integer>> loopList = new ArrayList<Map<String, Integer>>();			matcher = pattern.matcher(originalContent);			int index = 0;			while (matcher.find()) {				index = index + 1;				int start = matcher.start();				int end = matcher.end();				HashMap<String, Integer> value = new HashMap<String, Integer>();				value.put("start", Integer.valueOf(start));				value.put("end", Integer.valueOf(end));				loopList.add(value);				// Log.d(TAG, "the index=" + index + "=start=" + start + "=end="				// + end);			}			if (loopList.size() > 0) {				for (int curIndex = 0; curIndex < loopList.size(); curIndex++) {					if (curIndex == 0) {						loopList.get(curIndex).put("truestart", 0);					} else {						loopList.get(curIndex).put("truestart",								loopList.get(curIndex - 1).get("end"));					}				}			}			if (loopList.size() > 0) {				Spannable friendSpannable = new SpannableString(originalContent);				int mTrueStart = -1;				int mStart = -1;				int mEnd = -1;				for (int i = 0; i < loopList.size(); i++) {					mTrueStart = (Integer) ((HashMap<String, Integer>) loopList							.get(i)).get("truestart");					mStart = (Integer) ((HashMap<String, Integer>) loopList							.get(i)).get("start");					mEnd = (Integer) ((HashMap<String, Integer>) loopList							.get(i)).get("end");					newContent = newContent + normalPriex							+ originalContent.substring(mTrueStart, mStart)							+ normalSuffix;					newContent = newContent + bluePriex							+ originalContent.substring(mStart, mEnd)							+ normalSuffix;				}				newContent = newContent						+ normalPriex						+ originalContent.substring(mEnd,								originalContent.length()) + normalSuffix;			} else {				newContent = originalContent;			}		}		Log.d("the new Content==", newContent);		return newContent;	}	/**	 * 显示收藏和收藏字数的不同颜色的字体	 * 	 * @param textView	 * @param largeText	 *            大字体的字符串	 * @param samllText	 *            小字体的字符串	 */	public void setTextStyle(TextView textView, String largeText,			String samllText) {		String normalPriex = "<font color =\"black\">";		String normalSuffix = "</font>";		String bluePriex = "<font color =\"#A50100\">";		String newShowContent = normalPriex + largeText + normalSuffix				+ bluePriex + "  " + samllText + normalSuffix;		textView.setText(Html.fromHtml(newShowContent));	}	/**	 * 	 * @param hexEmoji	 * @return	 */	public static String emoji(int hexEmoji) {		return String.valueOf(Character.toChars(hexEmoji));	}	/**	 * 	 * @param strText	 * @return	 */	public static String unicodeEncode(String strText) {		char c;		String strRet = "";		int intAsc;		String strHex;		for (int i = 0; i < strText.length(); i++) {			c = strText.charAt(i);			intAsc = c;			if (intAsc > 128) {				strHex = Integer.toHexString(intAsc);				strRet += "\\u" + strHex;			} else {				strRet = strRet + c;			}		}		return strRet;	}	/**	 * 根据图片名获取资源ID	 * 	 * @param context	 * @param unicode	 * @return	 */	public static Drawable getFaceDrawable(Context context, String unicode) {		String drawableName = "emoji_" + unicode;		int id = context.getResources().getIdentifier(drawableName, "drawable",				context.getPackageName());		if (id == 0) {			return null;		}		return context.getResources().getDrawable(id);	}	/**	 * 格式化表情图片显示	 * 	 * @param face	 *            被处理的Bitmap	 * @param inSimple	 *            处理的比例值	 * @return	 */	public static Bitmap formatFaceBitmap(Bitmap face, int inSimple) {		int width = face.getWidth();		int height = face.getHeight();		// 设置想要的大小		int newWidth = width / inSimple;		int newHeight = height / inSimple;		// 计算缩放比例		float scaleWidth = ((float) newWidth) / width;		float scaleHeight = ((float) newHeight) / height;		// 取得想要缩放的matrix参数		Matrix matrix = new Matrix();		matrix.postScale(scaleWidth, scaleHeight);		// 得到新的图片		return Bitmap.createBitmap(face, 0, 0, width, height, matrix, true);	}	/**	 * 格式化图文混排显示的字符串	 * 	 * @param unicode	 *            表情图片对应的编码	 * @param imageSpan	 *            表情图片	 * @return	 */	public static SpannableString formatFaceString(String unicode,			ImageSpan imageSpan) {		SpannableString spannableString = new SpannableString(unicode);		spannableString.setSpan(imageSpan, 0, unicode.length(),				Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);		return spannableString;	}	/**	 * 格式化图文混排显示的字符串	 * 	 * @param unicode	 *            表情图片对应的编码	 * @param imageSpan	 *            表情图片	 * @return	 */	public static SpannableString formatFaceString(String content,			Drawable drawable) {		ImageSpan imageSpan = new ImageSpan(drawable);		SpannableString spannableString = new SpannableString(content);		spannableString.setSpan(imageSpan, 0, content.indexOf("</em>")				+ "</em>".length(), Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);		return spannableString;	}	/**	 * 格式化图文混排显示的字符串	 * 	 * @param unicode	 *            表情图片对应的编码	 * @param imageSpan	 *            表情图片	 * @return	 */	public static String formatFaceString(String content, int resID) {		if (content.contains("</em>")) {			String newString = "<img src=\"" + resID + "\" />";			String oldString = content.substring(0, content.indexOf("</em>")					+ "</em>".length());			return content.replace(oldString, newString);		}		return "";	}	/**	 * 字符串转换为Unicode编码	 * 	 * @param string	 * @return	 */	public static String convertStringToUnicode(String string) {		Charset charset = Charset.forName("GBK");		CharBuffer charBuffer = charset.decode(charset.encode(string));		return charBuffer.toString();	}	/**	 * 给Unicode添加识别标示字符串	 * 	 * @param unicode	 * @return	 */	public static String convertFaceString(String unicode) {		StringBuffer buffer = new StringBuffer();		buffer.append("<em>").append(unicode).append("</em>");		return buffer.toString();	}	/**	 * 解析包含emoji表情的文本内容为unicode数组	 * 	 * @param content	 * @return	 */	public static String[] parseUnicodesFromContent(String content) {		if (content.contains("<em>")) {			return content.split("<em>");		}		return null;	}	/**	 * 	 * 	 * @param content	 * @return	 */	public static String parseUnicodeFromContent(String content) {		if (content.contains("</em>")) {			return content.substring(0, content.indexOf("</em>"));		} else {			return content;		}	}	/**	 * 	 * 	 * @param content	 * @return	 */	public static int parseForamtFaceLength(String content) {		if (content.contains("</em>")) {			// 一个表情算两个字符			return content.substring(content.indexOf("</em>") + 5).length() + 2;		} else {			return content.length();		}	}	/**	 * 	 * 	 * @param content	 * @return	 */	public static boolean isContainsFaceCode(String content) {		if (content.contains("</em>")) {			return true;		} else {			return false;		}	}	/**	 * 	 * 	 * @param content	 * @return	 */	public static String parseUnicodeFromFormatContent(String content) {		if (content.contains("<em>")) {			return content.substring("<em>".length(), content.indexOf("</em>"));		} else {			return content;		}	}	/**	 * 	 * @param str	 * @return	 */	public static int[] toCodePointArray(String str) {		char[] ach = str.toCharArray();		int len = ach.length;		int[] acp = new int[Character.codePointCount(ach, 0, len)];		int j = 0;		for (int i = 0, cp; i < len; i += Character.charCount(cp)) {			cp = Character.codePointAt(ach, i);			acp[j++] = cp;		}		return acp;	}	/**	 * 	 * @param str	 */	public static Spanned formatEmojiFaceText(String str,			ImageGetter imageGetter) {		return Html.fromHtml(str, imageGetter, null);	}	/**	 * 	 * @param str	 */	public static Spanned formatEmojiFaceText(String str, final Context context) {		return Html.fromHtml(str, new ImageGetter() {			@Override			public Drawable getDrawable(String source) {				// TODO Auto-generated method stub				Drawable drawable = KUKUtil.getDrawable(context,						Integer.parseInt(source));				drawable.setBounds(0, 0, drawable.getIntrinsicWidth() / 2,						drawable.getIntrinsicHeight() / 2);				return drawable;			}		}, null);	}	/**	 * 	 * @param cs	 * @param mContext	 * @return	 */	public static String convertToMsg(CharSequence cs, Context mContext) {		SpannableStringBuilder ssb = new SpannableStringBuilder(cs);		ImageSpan[] spans = ssb.getSpans(0, cs.length(), ImageSpan.class);		for (int i = 0; i < spans.length; i++) {			ImageSpan span = spans[i];			int c = Integer.parseInt(span.getSource());			int a = ssb.getSpanStart(span);			int b = ssb.getSpanEnd(span);			ssb.replace(a, b, convertUnicode(c, mContext));		}		ssb.clearSpans();		return ssb.toString();	}	/**	 * 	 * @param resID	 * @param context	 * @return	 */	private static String convertUnicode(int resID, Context context) {		String unicode = KUKEmojiManager.getInstance(context).getEmojiInfoBy(				resID);		return convertUnicodeToFace(unicode);	}	/**	 * 	 * @param unicode	 * @return	 */	public static String convertUnicodeToFace(String unicode) {		return new String(Character.toChars(Integer.parseInt(unicode, 16)));	}	/**	 * 	 * @param str	 * @return	 */	public static Spanned getSpannedText(String str, Context context) {		if (str == null) {			return new SpannedString("");		}		String faceString = KUKEmojiManager.getInstance(context)				.parseEmojiFaceShowFromString(str);		return KUKUtil.formatEmojiFaceText(faceString, context);	}}